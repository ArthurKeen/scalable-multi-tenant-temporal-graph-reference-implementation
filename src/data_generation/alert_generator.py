#!/usr/bin/env python3
"""
Alert Data Generator

Generates realistic alert data for the multi-tenant temporal graph system.
Alerts are events (not configurations) generated by DeviceProxyOut and SoftwareProxyOut.

Author: Scalable Multi-Tenant Temporal Graph Reference Implementation
"""

import json
import random
import uuid
import sys
from datetime import datetime, timedelta
from pathlib import Path
from typing import Dict, List, Any, Tuple
from dataclasses import dataclass
from enum import Enum

# Add project root to path for imports
project_root = Path(__file__).parent.parent.parent
sys.path.insert(0, str(project_root))

from src.config.config_management import get_config, NamingConvention
from src.ttl.ttl_constants import TTLConstants, NEVER_EXPIRES
from src.utils.alert_naming import alert_namer
from src.config.generation_constants import GenerationConstants


class AlertType(Enum):
    """Types of alerts that can be generated."""
    HARDWARE = "hardware"
    SOFTWARE = "software" 
    SECURITY = "security"
    PERFORMANCE = "performance"
    CONNECTIVITY = "connectivity"


class AlertSeverity(Enum):
    """Alert severity levels."""
    CRITICAL = "critical"
    WARNING = "warning"
    INFO = "info"


class AlertStatus(Enum):
    """Alert status levels."""
    ACTIVE = "active"
    ACKNOWLEDGED = "acknowledged"
    RESOLVED = "resolved"


@dataclass
class AlertTemplate:
    """Template for generating realistic alerts."""
    alert_type: AlertType
    severity: AlertSeverity
    message_template: str
    metadata_template: Dict[str, Any]
    source_types: List[str]  # "device" or "software"


class AlertGenerator:
    """Generate realistic alert data for multi-tenant temporal graph."""
    
    def __init__(self, naming_convention: NamingConvention = NamingConvention.CAMEL_CASE):
        self.naming_convention = naming_convention
        self.app_config = get_config("production", naming_convention)
        self.base_timestamp = datetime.now()
        
        # Alert templates for realistic data generation
        self.alert_templates = [
            # Device Hardware Alerts
            AlertTemplate(
                AlertType.HARDWARE,
                AlertSeverity.CRITICAL,
                "CPU temperature critical: {temperature}Â°C",
                {"temperature": 85, "threshold": 80, "sensor": "cpu_temp"},
                ["device"]
            ),
            AlertTemplate(
                AlertType.HARDWARE, 
                AlertSeverity.WARNING,
                "Memory usage exceeded {threshold}%: {usage}%",
                {"usage": 87.3, "threshold": 85.0, "total_gb": 16},
                ["device"]
            ),
            AlertTemplate(
                AlertType.HARDWARE,
                AlertSeverity.CRITICAL,
                "Disk space critically low: {usage}% used on {partition}",
                {"usage": 97.2, "threshold": 95.0, "partition": "/var/log"},
                ["device"]
            ),
            
            # Device Connectivity Alerts
            AlertTemplate(
                AlertType.CONNECTIVITY,
                AlertSeverity.CRITICAL,
                "Connection to {target_ip} failed - interface {interface} down",
                {"target_ip": f"{GenerationConstants().IP_SUBNET_BASE}.1.100", "interface": "eth0", "connection_type": "ethernet"},
                ["device"]
            ),
            AlertTemplate(
                AlertType.CONNECTIVITY,
                AlertSeverity.WARNING,
                "High latency detected: {latency}ms to {target}",
                {"latency": 250, "threshold": 100, "target": "gateway"},
                ["device"]
            ),
            
            # Device Performance Alerts
            AlertTemplate(
                AlertType.PERFORMANCE,
                AlertSeverity.WARNING,
                "CPU usage sustained above {threshold}% for {duration} minutes",
                {"cpu_usage": 92.1, "threshold": 90.0, "duration": 5},
                ["device"]
            ),
            
            # Device Security Alerts
            AlertTemplate(
                AlertType.SECURITY,
                AlertSeverity.CRITICAL,
                "Multiple failed SSH login attempts: {attempts} from {source_ip}",
                {"attempts": 15, "source_ip": f"{GenerationConstants().IP_SUBNET_BASE}.1.200", "service": "ssh"},
                ["device"]
            ),
            
            # Software Application Alerts
            AlertTemplate(
                AlertType.SOFTWARE,
                AlertSeverity.CRITICAL,
                "{service_name} service crashed - restart failed",
                {"service_name": "mysql", "crash_time": "2024-01-15T14:30:00Z", "restart_attempts": 3},
                ["software"]
            ),
            AlertTemplate(
                AlertType.SOFTWARE,
                AlertSeverity.WARNING,
                "{service_name} response time degraded: {response_time}s average",
                {"service_name": "apache", "response_time": 2.3, "threshold": 1.0, "request_count": 1500},
                ["software"]
            ),
            
            # Software Performance Alerts
            AlertTemplate(
                AlertType.PERFORMANCE,
                AlertSeverity.WARNING,
                "Database query performance degraded: {avg_query_time}ms",
                {"avg_query_time": 850, "threshold": 500, "slow_queries": 23},
                ["software"]
            ),
            AlertTemplate(
                AlertType.PERFORMANCE,
                AlertSeverity.INFO,
                "Application memory usage increased: {memory_mb}MB",
                {"memory_mb": 1280, "previous_mb": 950, "increase_percent": 34.7},
                ["software"]
            ),
            
            # Software Security Alerts
            AlertTemplate(
                AlertType.SECURITY,
                AlertSeverity.CRITICAL,
                "Security vulnerability detected in {software_name}: {cve_id}",
                {"software_name": "openssl", "cve_id": "CVE-2024-0001", "severity": "HIGH"},
                ["software"]
            ),
        ]
        
    def generate_alert_data(self, tenant_data_dir: Path, active_ratio: float = 0.7) -> Tuple[List[Dict], List[Dict]]:
        """
        Generate alert data for a tenant.
        
        Args:
            tenant_data_dir: Directory containing tenant data files
            active_ratio: Ratio of alerts that should be active (vs resolved)
            
        Returns:
            Tuple of (alert_documents, hasAlert_edges)
        """
        # Load existing proxy data to generate alerts from
        device_proxies = self._load_proxy_data(tenant_data_dir, "device_outs")
        software_proxies = self._load_proxy_data(tenant_data_dir, "software_outs")
        
        alert_documents = []
        hasAlert_edges = []
        
        # Generate alerts from devices (60% of alerts)
        device_alerts = int(len(device_proxies) * 0.8)  # 80% of devices have alerts
        for i in range(device_alerts):
            proxy = random.choice(device_proxies)
            alert, edge = self._generate_alert_from_proxy(proxy, "device", active_ratio)
            alert_documents.append(alert)
            hasAlert_edges.append(edge)
            
        # Generate alerts from software (40% of alerts) 
        software_alerts = int(len(software_proxies) * 0.6)  # 60% of software have alerts
        for i in range(software_alerts):
            proxy = random.choice(software_proxies)
            alert, edge = self._generate_alert_from_proxy(proxy, "software", active_ratio)
            alert_documents.append(alert)
            hasAlert_edges.append(edge)
            
        return alert_documents, hasAlert_edges
    
    def _load_proxy_data(self, tenant_data_dir: Path, logical_name: str) -> List[Dict]:
        """Load proxy data from tenant directory."""
        try:
            collection_name = self.app_config.get_collection_name(logical_name)
            file_name = self.app_config.get_file_name(collection_name)
            file_path = tenant_data_dir / file_name
            
            if file_path.exists():
                with open(file_path, 'r') as f:
                    return json.load(f)
            else:
                print(f"[WARNING] Proxy file not found: {file_path}")
                return []
        except Exception as e:
            print(f"[ERROR] Failed to load proxy data: {e}")
            return []
    
    def _generate_alert_from_proxy(self, proxy: Dict, source_type: str, active_ratio: float) -> Tuple[Dict, Dict]:
        """Generate an alert and hasAlert edge from a proxy entity."""
        # Select appropriate alert template
        applicable_templates = [t for t in self.alert_templates if source_type in t.source_types]
        template = random.choice(applicable_templates)
        
        # Generate timestamps for alert lifecycle
        is_active = random.random() < active_ratio
        created_time = self._generate_alert_timestamp()
        
        # Create alert document
        alert_key = f"alert_{uuid.uuid4().hex[:8]}"
        alert_id = f"{self.app_config.get_collection_name('alerts')}/{alert_key}"
        
        # Generate metadata with some randomization
        metadata = self._randomize_metadata(template.metadata_template, source_type)
        message = template.message_template.format(**metadata)
        
        # Generate concise name for visualization using centralized utility
        proxy_name = proxy.get('name', 'Unknown')
        alert_name = alert_namer.generate_alert_name_from_template(
            template.severity, 
            template.alert_type, 
            proxy_name, 
            source_type
        )
        
        alert_doc = {
            "_key": alert_key,
            "_id": alert_id,
            "tenantId": proxy["tenantId"],
            "name": alert_name,
            "alertType": template.alert_type.value,
            "severity": template.severity.value,
            "status": AlertStatus.ACTIVE.value if is_active else AlertStatus.RESOLVED.value,
            "message": message,
            "created": created_time,
            "expired": NEVER_EXPIRES if is_active else created_time + random.randint(300, 7200),  # Resolved 5min-2hrs later
            "metadata": metadata
        }
        
        # Add TTL field for resolved alerts
        if not is_active:
            # Use demo TTL if available for shorter aging periods
            if hasattr(TTLConstants, 'DEMO_TTL_EXPIRE_SECONDS'):
                alert_doc["ttlExpireAt"] = alert_doc["expired"] + TTLConstants.DEMO_TTL_EXPIRE_SECONDS
                print(f"DEBUG: Setting TTL for resolved alert - expired={alert_doc['expired']}, ttlExpireAt={alert_doc['ttlExpireAt']}, diff={TTLConstants.DEMO_TTL_EXPIRE_SECONDS}s")
            else:
                # Production mode - 30 day TTL
                alert_doc["ttlExpireAt"] = alert_doc["expired"] + (30 * 24 * 60 * 60)
        
        # Create hasAlert edge
        edge_key = f"has_alert_{uuid.uuid4().hex[:8]}"
        hasAlert_edge = {
            "_key": edge_key,
            "_id": f"{self.app_config.get_collection_name('has_alerts')}/{edge_key}",
            "_from": proxy["_id"],
            "_to": alert_id,
            "tenantId": proxy["tenantId"],
            "relationshipType": "generated_by",
            "created": created_time,
            "expired": NEVER_EXPIRES if is_active else alert_doc["expired"]
        }
        
        # Add TTL field for resolved alert relationships
        if not is_active:
            hasAlert_edge["ttlExpireAt"] = alert_doc.get("ttlExpireAt")
            
        return alert_doc, hasAlert_edge
    
    def _generate_alert_timestamp(self) -> int:
        """Generate realistic alert timestamp (recent past)."""
        # Alerts within last 7 days, with bias toward more recent
        days_ago = random.choices(
            range(0, 7),
            weights=[40, 25, 15, 10, 5, 3, 2],  # Bias toward recent alerts
            k=1
        )[0]
        
        alert_time = self.base_timestamp - timedelta(days=days_ago)
        # Add random hours/minutes
        alert_time += timedelta(
            hours=random.randint(0, 23),
            minutes=random.randint(0, 59),
            seconds=random.randint(0, 59)
        )
        
        return int(alert_time.timestamp())
    
    def _randomize_metadata(self, template_metadata: Dict[str, Any], source_type: str) -> Dict[str, Any]:
        """Add realistic randomization to alert metadata."""
        metadata = template_metadata.copy()
        
        # Randomize numeric values by Â±20%
        for key, value in metadata.items():
            if isinstance(value, (int, float)) and key != "threshold":
                # Add some realistic variation 
                variation = random.uniform(0.8, 1.2)
                if isinstance(value, int):
                    metadata[key] = int(value * variation)
                else:
                    metadata[key] = round(value * variation, 1)
        
        # Add source-specific metadata
        if source_type == "device":
            metadata["device_type"] = random.choice(["router", "switch", "server", "firewall"])
        elif source_type == "software":
            metadata["software_type"] = random.choice(["web_server", "database", "application", "service"])
            
        return metadata
    
    def save_alert_data(self, tenant_data_dir: Path, alert_documents: List[Dict], hasAlert_edges: List[Dict]):
        """Save alert data to tenant directory."""
        # Save Alert documents
        alert_collection_name = self.app_config.get_collection_name("alerts")
        alert_file_name = self.app_config.get_file_name(alert_collection_name)
        alert_file_path = tenant_data_dir / alert_file_name
        
        with open(alert_file_path, 'w') as f:
            json.dump(alert_documents, f, indent=2)
        
        print(f"   [ALERT] Saved {len(alert_documents)} alert documents to {alert_file_name}")
        
        # Save hasAlert edges
        hasAlert_collection_name = self.app_config.get_collection_name("has_alerts")
        hasAlert_file_name = self.app_config.get_file_name(hasAlert_collection_name)
        hasAlert_file_path = tenant_data_dir / hasAlert_file_name
        
        with open(hasAlert_file_path, 'w') as f:
            json.dump(hasAlert_edges, f, indent=2)
            
        print(f"   [ALERT] Saved {len(hasAlert_edges)} hasAlert edges to {hasAlert_file_name}")
        
        # Print alert summary
        active_alerts = len([a for a in alert_documents if a["status"] == "active"])
        resolved_alerts = len(alert_documents) - active_alerts
        
        severity_counts = {}
        for alert in alert_documents:
            severity = alert["severity"]
            severity_counts[severity] = severity_counts.get(severity, 0) + 1
            
        print(f"   [SUMMARY] {active_alerts} active, {resolved_alerts} resolved")
        print(f"   [SUMMARY] Severity: {severity_counts}")


def main():
    """Demo/test the alert generator."""
    import argparse
    
    parser = argparse.ArgumentParser(description="Generate alert data for tenant")
    parser.add_argument("--tenant-dir", required=True, help="Tenant data directory")
    parser.add_argument("--naming", choices=["camelCase", "snake_case"], default="camelCase")
    parser.add_argument("--active-ratio", type=float, default=0.7, help="Ratio of active alerts (0.0-1.0)")
    
    args = parser.parse_args()
    
    naming = NamingConvention.CAMEL_CASE if args.naming == "camelCase" else NamingConvention.SNAKE_CASE
    generator = AlertGenerator(naming)
    
    tenant_dir = Path(args.tenant_dir)
    if not tenant_dir.exists():
        print(f"[ERROR] Tenant directory not found: {tenant_dir}")
        return
        
    print(f"[INFO] Generating alerts for tenant: {tenant_dir.name}")
    alerts, edges = generator.generate_alert_data(tenant_dir, args.active_ratio)
    generator.save_alert_data(tenant_dir, alerts, edges)
    print(f"[SUCCESS] Alert generation complete")


if __name__ == "__main__":
    main()
